const char* stdlibCode =
"format ELF64 executable\n"
"\n"
";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;[ BUFFERS ];;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"\n"
"; system buffers\n"
"__sumcNumberBuffer rb 128\n"
"__sumcNumberBufferLen = $-__sumcNumberBuffer\n"
"\n"
"__smucFileBuffer: rb 10*1024\n"
"__smucFileBufferCap = $-__smucFileBuffer\n"
"__smucFileBufferLen: rq 1\n"
"\n"
"__fileLinesCounter: dq 0\n"
"__fileLinesIterator: dq 0\n"
"\n"
"__smucStrCnt1: db \"There are \", 0\n"
"____smucStrCnt1Len = $-__smucStrCnt1\n"
"\n"
"__smucStrCnt2: db \" lines of code in '\", 0\n"
"____smucStrCnt2Len = $-__smucStrCnt2\n"
"\n"
"__smucStrCnt3: db \"'\", 0\n"
"____smucStrCnt3Len = $-__smucStrCnt3\n"
"\n"
"NL db 10\n"
"NLLen = $-NL\n"
"\n"
";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;[ SYSVALLS ];;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"\n"
"; fds\n"
"STDIN_FILENO equ 0\n"
"STDOUT_FILENO equ 1\n"
"STDERR_FILENO equ 2\n"
"\n"
"; syscalls\n"
"SYS_READ equ 0\n"
"SYS_WRITE equ 1\n"
"SYS_OPEN equ 2\n"
"SYS_CLOSE equ 3\n"
"SYS_EXIT equ 60\n"
"\n"
"; flags\n"
"O_RDONLY equ 0\n"
"\n"
"; syscalls\n"
"\n"
"macro syscall1 num, arg1 {\n"
"    mov rax, num\n"
"    mov rdi, arg1\n"
"    syscall\n"
"}\n"
"\n"
"macro syscall3 num, arg1, arg2, arg3 {\n"
"    mov rax, num\n"
"    mov rdi, arg1\n"
"    mov rsi, arg2\n"
"    mov rdx, arg3\n"
"    syscall\n"
"}\n"
"\n"
";; syscalls wrappers tier 1\n"
"\n"
"macro write fd, buf, bufSize {\n"
"    syscall3 SYS_WRITE, fd, buf, bufSize\n"
"}\n"
"\n"
"macro read fd, buf, bufSize {\n"
"    syscall3 SYS_READ, fd, buf, bufSize\n"
"}\n"
"\n"
"macro exit code {\n"
"    syscall1 SYS_EXIT, code\n"
"}\n"
"\n"
";; syscalls wrappers tier 2\n"
"\n"
"macro printStr string {\n"
"    write STDOUT_FILENO, string, __#string#Len\n"
"}\n"
"\n"
"macro printNL {\n"
"    write STDOUT_FILENO, NL, NLLen\n"
"}\n"
"\n"
"macro exitOk {\n"
"    exit nil\n"
"}\n"
"\n"
"macro printStrNL string {\n"
"    printStr string\n"
"    printNL\n"
"}\n"
"\n"
";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;[ I/O ];;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"\n"
"_print_number_buffer:\n"
"    syscall3 1, 1, r14, 1\n"
"    dec r14\n"
"\n"
"    cmp r14, __sumcNumberBuffer ;; same way to comapre byte [r14], 10\n"
"    jge _print_number_buffer\n"
"\n"
"    ret\n"
"\n"
"_fill_in_the_buffer:\n"
"    mov rdx, 0    ;; to store a remainder\n"
"    mov rbx, 10   ;; divider\n"
"    div rbx       ;; rax = rax / rbx and remainder in rdx if rdx is zero\n"
"\n"
"    mov rcx, 48\n"
"    add rcx, rdx\n"
"    mov byte [r14], cl\n"
"    inc r14\n"
"\n"
"    cmp rax, 0\n"
"    jne _fill_in_the_buffer\n"
"\n"
"    dec r14\n"
"    call _print_number_buffer\n"
"\n"
"    ret\n"
"\n"
"; number in register rax\n"
"_print_number:\n"
"    mov r14, __sumcNumberBuffer ;; __sumcNumberBuffer iterator\n"
"    ; mov qword [r14], 10         ;; new line\n"
"    ; inc r14\n"
"    jmp _fill_in_the_buffer\n"
"\n"
"; number in register rax\n"
"_print_number_nl:\n"
"    mov r14, __sumcNumberBuffer ;; __sumcNumberBuffer iterator\n"
"    mov qword [r14], 10         ;; new line\n"
"    inc r14\n"
"    jmp _fill_in_the_buffer\n"
"\n"
"; numbers printing\n"
"\n"
"macro printNum number {\n"
"    save2 rax, r14\n"
"    mov rax, number\n"
"    call _print_number\n"
"    extract2 rax, r14\n"
"}\n"
"\n"
"macro printVarNum number {\n"
"    save2 rax, r14\n"
"    mov rax, [number]\n"
"    call _print_number\n"
"    extract2 rax, r14\n"
"}\n"
"\n"
"macro printNumNL number {\n"
"    save2 rax, r14\n"
"    mov rax, number\n"
"    call _print_number_nl\n"
"    extract2 rax, r14\n"
"}\n"
"\n"
"macro printVarNumNL number {\n"
"    save2 rax, r14\n"
"    mov rax, [number]\n"
"    call _print_number_nl\n"
"    extract2 rax, r14\n"
"}\n"
"\n"
";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;[ FUNCTIONS ];;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"\n"
"; stack\n"
"macro prolog {\n"
"    push rbp\n"
"    mov rbp, rsp\n"
"}\n"
"\n"
"macro funcVarCnt bytesCnt {\n"
"    sub rsp, (bytesCnt*8)\n"
"}\n"
"\n"
"macro freeFuncVars bytesCnt {\n"
"    add rsp, (bytesCnt*8)\n"
"}\n"
"\n"
"macro epilog  {\n"
"    pop rbp\n"
"    ret\n"
"}\n"
"\n"
"; function definitions\n"
"\n"
"varscount fix ,\n"
"\n"
"macro func funcName, varC {\n"
"    if funcName in <main>\n"
"        entry _start\n"
"        _start:\n"
"            prolog\n"
"            funcVarCnt varC\n"
"    else\n"
"        funcName:\n"
"            prolog\n"
"            funcVarCnt varC\n"
"    end if\n"
"}\n"
"\n"
"macro funcEnd varC {\n"
"    freeFuncVars varC\n"
"    epilog\n"
"}\n"
"\n"
";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;[ FILES ];;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"\n"
"; rdi - file path\n"
"read_file:\n"
"    push rbp\n"
"    mov rbp, rsp\n"
"    sub rsp, 8\n"
"\n"
"    ; mov rdi, file_path rdi already contains file_path\n"
"    syscall3 SYS_OPEN, rdi, O_RDONLY, 0\n"
"    cmp rax, 0\n"
"    jl .failed\n"
"\n"
"    mov [rbp-8], rax ; file descriptor\n"
"\n"
"    syscall3 SYS_READ, [rbp-8], __smucFileBuffer, __smucFileBufferCap\n"
"    cmp rax, 0\n"
"    jl .failed\n"
"\n"
"    mov [__smucFileBufferLen], rax\n"
"\n"
"    syscall1 SYS_CLOSE, [rbp-8]\n"
"\n"
".failed:\n"
"    add rsp, 8\n"
"    pop rbp\n"
"    ret\n"
"\n"
"macro dumpFileContent fileName {\n"
"    mov rdi, fileName\n"
"    call read_file\n"
"    cmp rax, 0\n"
"    jl _fail_read_file#fileName\n"
"    write STDOUT_FILENO, __smucFileBuffer, __smucFileBufferLen\n"
"    jmp _nextHop#fileName\n"
"_fail_read_file#fileName:\n"
"    exit rax\n"
"_nextHop#fileName:\n"
"}\n"
"\n"
"macro dumpFileLinesNumber fileName {\n"
"    for __fileLinesIterator, 0, [__smucFileBufferLen]\n"
"        mov rax, __smucFileBuffer\n"
"        add rax, [__fileLinesIterator]\n"
"        mov bl, byte [rax]\n"
"        mov rcx, [__fileLinesCounter]\n"
"        mov rdx, rcx\n"
"        inc rcx\n"
"        cmp bl, 10\n"
"        cmove rdx, rcx ; restore previous count val from rax if current byte not '\\n'.\n"
"        mov [__fileLinesCounter], rdx\n"
"    endfor __fileLinesIterator\n"
"\n"
"    printNL\n"
"\n"
"    printStr __smucStrCnt1\n"
"    printVarNum __fileLinesCounter\n"
"    printStr __smucStrCnt2\n"
"    printStr fileName\n"
"    printStrNL __smucStrCnt3\n"
"\n"
"    mov qword [__fileLinesCounter], 0\n"
"}\n"
"\n"
";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;[ SOME STUFF ];;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"\n"
";; for loop\n"
"\n"
"macro for i, from, to {\n"
"    mov QWORD [i], from\n"
".#i#_again:\n"
"    save1 r14\n"
"    mov r14, QWORD [i]\n"
"    cmp r14, to\n"
"    extract1 r14\n"
"    jge .#i#_over\n"
"}\n"
"\n"
"macro endfor i {\n"
"    inc QWORD [i]\n"
"    jmp .#i#_again\n"
".#i#_over:\n"
"}\n"
"\n"
"; variables\n"
"\n"
"is fix ,\n"
"\n"
"macro let varName, varType, varVal {\n"
"    if varType in <int>\n"
"        varName: dq varVal\n"
"    else\n"
"        if varType in <str>\n"
"            varName: db varVal, 0\n"
"            __##varName#Len = $-varName\n"
"        end if\n"
"    end if\n"
"}\n"
"\n"
"; functions stack variables\n"
"\n"
"macro flet varSeqNo, type, varVal {\n"
"    if type in <int>\n"
"        mov [rbp-(varSeqNo*8)], dword varVal\n"
"    else\n"
"        if type in <str>\n"
"          \n"
"        else\n"
"\n"
"        end if\n"
"    end if\n"
"}\n"
"\n"
"macro fprintNum varSeqNo {\n"
"    printNum [rbp-(varSeqNo*8)]\n"
"}\n"
"\n"
"macro fprintNumNL varSeqNo {\n"
"    printNumNL [rbp-(varSeqNo*8)]\n"
"}\n"
"\n"
"; some stuff\n"
"nil equ 0\n"
"\n"
"macro save1 reg1 {\n"
"    push reg1\n"
"}\n"
"\n"
"macro extract1 reg1 {\n"
"    pop reg1\n"
"}\n"
"\n"
"macro save2 reg1, reg2 {\n"
"    save1 reg1\n"
"    save1 reg2\n"
"}\n"
"\n"
"macro extract2 reg1, reg2 {\n"
"    extract1 reg1\n"
"    extract1 reg2\n"
"}\n";
